default namespace = "http://ruleml.org/spec"
namespace ns1 = "http://www.w3.org/2001/XMLSchema-instance"

start =
  RuleML
  | Assert
  | Retract
  | Query
  | Atom
  | Rel
  | And
  | Or
  | Implies
  | Forall
  | Exists
  | Expr
  | Fun
  | Rulebase
  | Entails
  | Neg
  | Naf
  | Equivalent
  | Equal
  | Data
  | Skolem
  | Reify
  | Ind
  | Var
  | Plex
  | degree
  | meta
  | oid
  | slot
  | resl
  | repo
RuleML =
  element RuleML {
    (attribute node {
       xsd:string {
         pattern =
           "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         minLength = "1"
       }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    (Assert | Retract | Query)*
  }
Assert =
  element Assert {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    (Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists
     | Entails
     | Rulebase)*
  }
Retract =
  element Retract {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    (Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists
     | Entails
     | Rulebase)*
  }
Query =
  element Query {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    (Atom
     | Equal
     | And
     | Or
     | Neg
     | Naf
     | Implies
     | Equivalent
     | Forall
     | Exists
     | Entails
     | Rulebase)*
  }
Atom =
  element Atom {
    (attribute closure {
       "universal"
       | "existential"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    oid?,
    degree?,
    Rel,
    (Skolem | Reify | Ind | Data | Var | Expr | Plex)*,
    repo?,
    slot*,
    resl?
  }
Rel =
  element Rel {
    (attribute iri {
       xsd:string {
         pattern =
           "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         minLength = "1"
       }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    xsd:token
  }
And =
  element And {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    degree?
  }
Or =
  element Or {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    degree?
  }
Implies =
  element Implies {
    (attribute direction {
       "bidirectional"
       | "forward"
       | "backward"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute material {
         "yes"
         | "no"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapMaterial {
         "yes"
         | "no"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    degree?,
    (Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Naf
     | Implies
     | Equivalent
     | Forall
     | Exists),
    (Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists)
  }
Forall =
  element Forall {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    degree?,
    Var+,
    (Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists)
  }
Exists =
  element Exists {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    degree?,
    Var+,
    (Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists)
  }
Expr =
  element Expr {
    (attribute per {
       "copy"
       | "value"
       | "open"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute type {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    oid?,
    Fun,
    (Skolem | Reify | Ind | Data | Var | Expr | Plex)*,
    repo?,
    slot*,
    resl?
  }
Fun =
  element Fun {
    (attribute per {
       "copy"
       | "value"
       | "open"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute val {
         "1"
         | "0.."
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute iri {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    xsd:token
  }
Rulebase =
  element Rulebase {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    (Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists)*
  }
Entails =
  element Entails {
    (attribute node {
       xsd:string {
         pattern =
           "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         minLength = "1"
       }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    (Rulebase
     | Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists),
    (Rulebase
     | Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists)
  }
Neg =
  element Neg {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    degree?,
    (Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists)
  }
Naf =
  element Naf {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    degree?,
    (Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists)
  }
Equivalent =
  element Equivalent {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    degree?,
    (Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists),
    (Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists)
  }
Equal =
  element Equal {
    (attribute oriented {
       "no"
       | "yes"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    degree?,
    (Skolem | Reify | Ind | Data | Var | Expr | Plex),
    (Skolem | Reify | Ind | Data | Var | Expr | Plex)
  }
Data =
  element Data {
    attribute node {
      xsd:string {
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        minLength = "1"
      }
      | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?
    & attribute ns1:schemaLocation { text }?
    & attribute xml:base { xsd:anyURI }?
    & attribute xml:id { xsd:NCName }?
    & attribute key {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & attribute keyref {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & text
    & _1*
  }
Skolem =
  element Skolem {
    (attribute type {
       xsd:string {
         pattern =
           "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         minLength = "1"
       }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    xsd:token
  }
Reify =
  element Reify {
    attribute node {
      xsd:string {
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        minLength = "1"
      }
      | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?
    & attribute ns1:schemaLocation { text }?
    & attribute xml:base { xsd:anyURI }?
    & attribute xml:id { xsd:NCName }?
    & attribute key {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & attribute keyref {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & (RuleML
       | Assert
       | Retract
       | Query
       | Atom
       | Rel
       | And
       | Or
       | Implies
       | Forall
       | Exists
       | Expr
       | Fun
       | Rulebase
       | Entails
       | Neg
       | Naf
       | Equivalent
       | Equal
       | Data
       | Skolem
       | Reify
       | Ind
       | Var
       | Plex
       | degree
       | meta
       | oid
       | slot
       | resl
       | repo)*
  }
Ind =
  element Ind {
    (attribute iri {
       xsd:string {
         pattern =
           "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         minLength = "1"
       }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute type {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    xsd:token
  }
Var =
  element Var {
    (attribute type {
       xsd:string {
         pattern =
           "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         minLength = "1"
       }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    xsd:token
  }
Plex =
  element Plex {
    (attribute node {
       xsd:string {
         pattern =
           "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         minLength = "1"
       }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    (Skolem | Reify | Ind | Data | Var | Expr | Plex)*,
    repo?,
    slot*,
    resl?
  }
degree =
  element degree {
    attribute ns1:schemaLocation { text }?
    & attribute xml:base { xsd:anyURI }?
    & attribute xml:id { xsd:NCName }?
    & attribute key {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & attribute keyref {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & Data
  }
meta =
  element meta {
    attribute ns1:schemaLocation { text }?
    & attribute xml:base { xsd:anyURI }?
    & attribute xml:id { xsd:NCName }?
    & attribute key {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & attribute keyref {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & (Atom
       | Equal
       | And_2
       | Or_2
       | Neg
       | Implies
       | Equivalent
       | Forall
       | Exists
       | Entails
       | Rulebase)
  }
oid =
  element oid {
    attribute ns1:schemaLocation { text }?
    & attribute xml:base { xsd:anyURI }?
    & attribute xml:id { xsd:NCName }?
    & attribute key {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & attribute keyref {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & (Skolem | Reify | Ind | Data | Var | Expr | Plex)
  }
slot =
  element slot {
    (attribute card { xsd:nonNegativeInteger }?
     & attribute weight {
         xsd:decimal { minInclusive = "0.0" maxInclusive = "1.0" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    (Ind | Data | Expr | Plex),
    (Skolem | Reify | Ind | Data | Var | Expr | Plex)
  }
resl =
  element resl {
    attribute ns1:schemaLocation { text }?
    & attribute xml:base { xsd:anyURI }?
    & attribute xml:id { xsd:NCName }?
    & attribute key {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & attribute keyref {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & (Var | Plex_2)
  }
repo =
  element repo {
    attribute ns1:schemaLocation { text }?
    & attribute xml:base { xsd:anyURI }?
    & attribute xml:id { xsd:NCName }?
    & attribute key {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & attribute keyref {
        xsd:string {
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
          minLength = "1"
        }
        | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
      }?
    & (Var | Plex_3)
  }
And_2 =
  element And {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    degree?
  }
Or_2 =
  element Or {
    (attribute mapMaterial {
       "yes"
       | "no"
       | xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute mapDirection {
         "bidirectional"
         | "forward"
         | "backward"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute node {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute closure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute mapClosure {
         "universal"
         | "existential"
         | xsd:string {
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
             minLength = "1"
           }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    degree?
  }
_1 =
  element * {
    attribute * { text }*,
    (text & _1*)
  }
Plex_2 =
  element Plex {
    (attribute node {
       xsd:string {
         pattern =
           "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         minLength = "1"
       }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    slot*,
    resl?
  }
Plex_3 =
  element Plex {
    (attribute node {
       xsd:string {
         pattern =
           "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         minLength = "1"
       }
       | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
     }?
     & attribute ns1:schemaLocation { text }?
     & attribute xml:base { xsd:anyURI }?
     & attribute xml:id { xsd:NCName }?
     & attribute key {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?
     & attribute keyref {
         xsd:string {
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           minLength = "1"
         }
         | xsd:string { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?),
    meta*,
    (Skolem | Reify | Ind | Data | Var | Expr | Plex)*,
    repo?
  }

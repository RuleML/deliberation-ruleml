<?xml version="1.0" encoding="ISO-8859-1" ?>
<?xml-stylesheet href="homepage2.xsl" type="text/xsl"?>

<homepage>

  <title>Schema Specification of RuleML 1.0 </title>

	<opening>
		<center>
			<br/>
			<br/>
			<h1>Schema Specification of RuleML 1.0</h1>


                        <h2>
                                <a href="http://www.cs.unb.ca/~boley/">Harold Boley</a>,
                          <a href="http://www.alt2is.com/">Tara Athan</a>,
                          <a href="http://www.corporate-semantic-web.de/">Adrian Paschke</a>,
                                <a href="http://home.comcast.net/~stabet/">Said Tabet</a>,
                                <a href="http://www.mit.edu/~bgrosof/">Benjamin Grosof</a>,<br />
                                <a href="http://lpis.csd.auth.gr/people/nbassili/">Nick Bassiliades</a>,
                                <a href="http://www.governatori.net/">Guido Governatori</a>,
                                <a href="http://www.cs.uwaterloo.ca/~dhirtle/">David Hirtle</a>,
                                <a href="http://sites.google.com/site/omairshafiq/">Omair Shafiq</a>,
                          <a href="http://pl.linkedin.com/pub/monika-machunik/10/9a4/b0a">Monika Machunik</a>
                        </h2>


			<table border="0" align="center">
			<tr><td colspan="2" align="center"><h2>Version history:</h2></td></tr>
			<tr><td align="right">2001-01-25 - </td><td><a href="http://www.ruleml.org/indtd.html">Version 0.7</a></td></tr>
			<tr><td align="right">2001-07-11 - </td><td><a href="http://www.ruleml.org/indtd0.8.html">Version 0.8</a></td></tr>
			<tr><td align="right">2003-12-09 - </td><td><a href="http://www.ruleml.org/0.85/">Version 0.85</a></td></tr>
			<tr><td align="right">2004-06-23 - </td><td><a href="http://www.ruleml.org/0.86/">Version 0.86</a></td></tr>
			<tr><td align="right">2004-08-12 - </td><td><a href="http://www.ruleml.org/0.87/">Version 0.87</a></td></tr>
			<tr><td align="right">2005-03-01 - </td><td><a href="http://www.ruleml.org/0.88/">Version 0.88</a></td></tr>
			<tr><td align="right">2005-05-27 - </td><td><a href="http://www.ruleml.org/0.89/">Version 0.89</a></td></tr>
			<tr><td align="right">2005-11-09 - </td><td><a href="http://www.ruleml.org/0.9/">Version 0.9</a></td></tr>
			<tr><td align="right">2006-08-24 - </td><td><a href="http://www.ruleml.org/0.91/">Version 0.91</a></td></tr>
			<tr><td align="right">2011-05-14 - </td><td><a href="http://www.ruleml.org/0.91/">Version 0.91 Patched</a></td></tr>
			<tr><td align="right"><h3>2011-12-09 - </h3></td><td><h3><a href="http://www.ruleml.org/1.0/">Version 1.0</a></h3></td></tr>
			</table>			

			<h2>Latest version: <a href="http://www.ruleml.org/spec/">www.ruleml.org/spec/</a></h2>
			<p/>
			<h2>Quick links:</h2>
			<h2><a href="http://www.ruleml.org/1.0/xsd/content_models_10.pdf">Content Models</a>,
			<a href="http://www.ruleml.org/1.0/xsd/">Schemas</a>,
			<a href="http://www.ruleml.org/1.0/xslt/normalizer/">Normalizer</a>,
			<a href="http://www.ruleml.org/1.0/xslt/upgrader/">Upgrader</a>,
			<a href="http://www.ruleml.org/1.0/exa/">Examples</a>,
			  <a href="http://www.ruleml.org/1.0/glossary/">Glossary</a>,
			  <a href="http://wiki.ruleml.org/index.php/RuleML_Implementations">Implementations</a>
			</h2>
		</center>
		<br/>
	  <!--<p>This is the specification for RuleML version 1.0, as the overarching specification of Web rules that encompasses RIF RuleML as a subfamily, and takes into account corresponding OASIS, OMG (e.g., PRR, SBVR), and ISO (e.g., Common Logic) specifications. </p>-->
<!--	  <p>
	  Rules on the Web come in various formats and with diverse packaging.
	  Often, however, the semantics of Web-distributed rule content are compatible.
	  In such cases, rulebases can be reused with an interchange technology consisting of a family of canonical rule languages and bi-directional translators between canonical languages and the languages to be interchanged.
	  The need for Web rule interchange has been increasing with the amount of business rules (incl. policies, regulations, laws, ...) in many domains (e.g. finance, engineering, healthcare, ...) on the Web 1.0, 2.0 (Social), and 3.0 (Social Semantic).	  
	  </p> -->
<p>
RuleML has been designed for the interchange of
the major kinds of Web rules in an XML format that is uniform across various rule languages and platforms. It has broad coverage and is defined as an extensible family of languages, whose modular system of schemas permits rule interchange with high precision.</p>
	  <p>The scope of this specification covers </p>
	  <!--  
	    <ul>
	    <li>syntax, including 
	        <ul>
	          <li>abstract syntax</li> 
	          <li>XML syntax, including -->
	          <ul>
	            <li>content models for the named sublanguages, available from <a href="http://www.ruleml.org/1.0/xsd/content_models_10.pdf">Content Model Document</a></li>
	            <li>schemas, including
	              <ul>
	                <li><a href="http://www.ruleml.org/1.0/xsd/">schemas in XML Schema Definition Language (XSD) with Schematron annotation</a></li>
	                <li><a href="http://www.ruleml.org/1.0/relaxng/">schemas in Relax NG</a></li>
	              </ul>
	            </li> 
	            <li>a mapping from the RuleML Version 1.0 syntax to the "normalized" RuleML Version 1.0 syntax as given in the <a href="http://www.ruleml.org/1.0/xslt/normalizer/100_normalizer.xslt">XSLT Normalizer</a><!--@@@ this links to the old, defective normalizer  @@@ stylesheet--></li>
	            <li>a mapping from the preceding RuleML Version 0.91 XML syntax to RuleML Version 1.0 XML syntax as given in the <a href="http://www.ruleml.org/1.0/xslt/upgrader/091-to-ruleml100.xslt">XSLT Upgrader</a> stylesheet</li>
	            
	          </ul>
	        <!--</li>
	            <li>presentation syntax</li>
	          
	        </ul>
	        </li>
	      <li>semantics, including
	        <ul>
	      <li>an informal semantics as given in the <a href="http://www.ruleml.org/1.0/glossary/">Glossary</a></li>
	          <li>formal model-theoretic semantics</li> 
	          <li>formal proof-theoretic semantics</li>
	          
	        </ul>
	      </li>
	      </ul> -->
	  <p>The scope of this specification does not cover applications that make use of RuleML languages, such as parsers, inference engines or editors. For a listing of such applications, see the RuleML <a href="http://wiki.ruleml.org/index.php/RuleML_Implementations">Implementations</a> wiki page.</p>
	  <p>RuleML Version 1.0 is a "Rosetta Stone" release where two schema languages, XSD and Relax NG, are independently employed to formalize the syntax, to the extent possible within each language. See <a href="http://www.cs.unb.ca/~boley/papers/RuleMLinRelaxNG.pdf">Design and Implementation of Highly Modular Schemas for XML: Customization of RuleML in Relax NG</a> and the RuleML <a href="http://wiki.ruleml.org/index.php/Relax_NG">MYNG</a> wiki page for the details of this re-engineering effort. MYNG is an acronym for "Modular sYNtax confiGurator", or "Modularize Your NG", and may be pronounced either "ming" or "my N G". </p>
		<p>The RuleML Version 1.0 XSD schemas are a minor modification of the patched XSD schemas of RuleML Version 0.91, which follow the tree-based <a href="http://www.ruleml.org/modularization">modularization approach</a>. <!--@@@The XSD schemas are permissive for certain invalid syntactic constructs as expressed by the Schematron annotations @@@ the Schematron rules should be separated out so that they may be applied independently of choice of XSD or Relax NG schema language@@@, and are also conservative in that certain permutations of elements are allowed in the normative syntax but are not implemented in the XSD schemas.@@@-->
		  A procedure for validation against the XSD schemas is described in <a href="#Appendix-3">Appendix 3</a>.  
		</p>
	  <p>The RuleML Version 1.0 Relax NG schemas are a new component of the RuleML Version 1.0 release, and are intended to replace the hand-written XSD schemas in future releases. The Relax NG schemas are available for two serializations, "normal" and "relaxed". The relaxed-form serialization is permissive relative to the specification in the Content Model document, i. e. every RuleML version 1.0 instance that is valid with respect to the Content Model document will validate against the relaxed serialization Relax NG schemas. The normal serialization Relax NG schemas validate instances in the normal form, which is described in the <a href="#Normalization">Normalization</a> section. Procedures for validation against the Relax NG schemas is described in <a href="#Appendix-5">Appendix 5</a>.</p>
	  <p>Note that the Document Type Definition (DTD) specification of RuleML is no longer being maintained, but will continue to be <a href="http://www.ruleml.org/0.85/dtd">available as an archive</a>. Tools capable of converting between XML Schema and DTDs such as <a href="http://www.altova.com/xml-editor/">XMLSpy</a> are always available.</p>
		
	</opening>

<section>
	<header>Overview</header>
	<p>An introduction to RuleML is given in our <a href="http://www.ruleml.org/papers/tutorial-ruleml.html">tutorial</a>. <!--@@@ this tutorial is out-of-date @@@.--> Also, the main page's <a href="http://www.ruleml.org/index.html#Design">design section</a> discusses the upper layer of the RuleML hierarchy of rules. In that terminology, the system of RuleML XSDs presented here only covers derivation rules, not reaction rules (see the <a href="http://www.ruleml.org/modularization/#Model">official model</a>).</p>
	<p>This is because we think it is important to start with a subset of simple rules, test and refine our principal strategy using these, and then work 'up' to the more general categories of rules in the hierarchy.
	  </p>
	
	<p>Below is a summary of the changes in version 1.0:</p>

	<itemize>
	
		<item>Schematron dependency has been reduced (as comments in the code) </item>	
		<item>Role tags <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code>, replaced with <code>&lt;then&gt;</code> and <code>&lt;if&gt;</code>, respectively </item>	
		<item>Role tags <code>&lt;lhs&gt;</code> and <code>&lt;rhs&gt;</code>, replaced with <code>&lt;left&gt;</code> and <code>&lt;right&gt;</code>, respectively </item>	
		<item>Type tags <code>&lt;Hterm&gt;</code> and <code>&lt;Con&gt;</code>, replaced with <code>&lt;Uniterm&gt;</code> and <code>&lt;Const&gt;</code> respectively </item>	
		<item>Attribute <code>in="no|semi|yes"</code> with respective values, replaced with <code>per="copy|open|value"</code></item> 
	  <item>Attribute <code>uri</code> replaced with <code>iri</code> </item> 
	  <item>New role tag <code>act</code> introduced for all content of <code>RuleML</code> element </item>
	  <item>The Normalizer at <a href="http://ruleml.org/1.0/xslt/normalizer/100_normalizer.quarantine.xslt">http://ruleml.org/1.0/xslt/normalizer/100_normalizer.quarantine.xslt</a> has been deprecated. A refactored Normalizer is under development at <a href="http://v37s3b4h7dn47s37hg1br4h7rs7n3du7s8nu.unbf.ca/~lbidlak1/">http://v37s3b4h7dn47s37hg1br4h7rs7n3du7s8nu.unbf.ca/~lbidlak1/</a>.</item>
	  <item>Features that are "at risk" of being deprecated in future release, including: 
	    <itemize>
	    <item><code>Reify</code> at Datalog and lower, as this introduces the possibility of nesting reification to an arbitrary level </item>
	      <item> the default values of attributes which indicate semantics variants: 
	        <code>direction</code>, 
	        <code>mapDirection</code>,
	        <code>material</code>,
	        <code>mapMaterial</code>,
	        <code>oriented</code>,
	        <code>val</code>,
	        <code>per</code>, as it may be more effective to use the absence of the attribute to indicate a "neutral" semantics.
	      </item>
	    </itemize>
	    </item>
	</itemize>	

	<p>For more information, see the <a href="#Changes">Changes</a> section.</p>

	<p>A comprehensive <a href="#Glossary">glossary</a> accompanies this specification.</p>
	
	<p>The grammar of RuleML 1.0 (i.e. the content model of each individual tag) is available as a single document called <a href="xsd/content_models_10.pdf">Content Models for RuleML</a> in addition to being partially specified within the <a href="xsd/">XML Schemas</a> and <a href="relaxng/">Relax NG Schemas</a>.
	</p>

</section>   

<section>

	<header>Changes</header>

	<p>Changes in the RuleML 1.0 XSD release relative to the previous XSD version <a href="http://www.ruleml.org/0.91/">0.91</a> are detailed below, including examples where appropriate.</p>
  
  <p>Schematron dependency has been reduced (as comments in the code). For example, the following code provides annotation related to restrictions 
     on the interpretation attribute of nested functions.
<box><pre><![CDATA[<xs:annotation>
  <xs:appinfo>
    <sch:pattern name="Uninterpreted functions">
      <sch:rule context="r:Expr/r:Fun[@per='no']">
        <sch:assert test=
          "not(../r:Expr/r:Fun[@per='yes'] or
           ../r:arg/r:Expr/r:Fun[@per='yes'] or
           ../r:Expr/r:op/r:Fun[@per='yes'] or 
           ../r:arg/r:Expr/r:op/r:Fun[@per='yes'])">
          Functions nested within an uninterpreted function must also be uninterpreted.
        </sch:assert>
      </sch:rule>
    </sch:pattern>
  </xs:appinfo>
</xs:annotation>]]></pre></box>  
  </p>
  <p>Role tags <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> are replaced with <code>&lt;then&gt;</code> and <code>&lt;if&gt;</code>, respectively.
    These tags appear as children of <code>&lt;Implies&gt;</code> and <code>&lt;Entails&gt;</code>.
    For example, the following implication:
  <box><pre><![CDATA[<Implies>
  <if>
    <And>
      <Atom>
        <Rel>premium</Rel>
        <Var>cust</Var>
      </Atom>
      <Atom>
        <Rel>regular</Rel>
        <Var>prod</Var>
      </Atom>
    </And>
  </if>
  <then>
    <Atom>
      <Rel>discount</Rel>
      <Var>cust</Var>
      <Var>prod</Var>
      <Data>5.0 percent</Data>
    </Atom>
  </then>
</Implies>]]></pre></box>
  expresses the statement "A premium customer recieves a 5% discount on regular products."</p>
  <p>Role tags <code>&lt;lhs&gt;</code> and <code>&lt;rhs&gt;</code> are replaced with <code>&lt;left&gt;</code> and <code>&lt;right&gt;</code>, respectively. 
    These tags appear as children of <code>&lt;Equal&gt;</code>. As an example consider the statement:
    <box><pre><![CDATA[<Equal>    
  <left>
    <Ind>Lady Gaga</Ind>
  </left>
  <right>
    <Ind>Stefani Joanne Angelina Germanotta</Ind>
  </right>
</Equal>]]></pre></box>
  which expresses that the individuals named "Lady Gaga" and "Stefani Joanne Angelina Germanotta" are the same.</p>
  
  <p>In the SWSL languages, which are implemented only in the XSDs, type tags <code>&lt;Hterm&gt;</code> and <code>&lt;Con&gt;</code> are replaced with <code>&lt;Uniterm&gt;</code> and <code>&lt;Const&gt;</code> respectively. </p>	
  
  <p>Attribute <code>in="no|semi|yes"</code> with respective values are replaced with <code>per="copy|open|value"</code>.
  For example, the following functional expression uses the default value ("copy") of the attribute "per" 
    <box><pre><![CDATA[<Expr per="copy">
  <op><Fun>MultiplyFn</Fun></op>
  <arg index="1"><Data xsi:type="xs:integer">3</Data></arg>
  <arg index="2"><Var>X</Var></arg>
</Expr>]]></pre></box>
  to generate an algebraic expression that may be evaluated after the variable X is bound to a numerical value.
    In contrast, the expression
    <box><pre><![CDATA[<Expr per="value">
  <op><Fun>MultiplyFn</Fun></op>
  <arg index="1"><Data xsi:type="xs:integer">3</Data></arg>
  <arg index="2"><Data xsi:type="xs:integer">4</Data></arg>
</Expr>]]></pre></box>
  will be evaluated (to <Data xsi_type="xs:integer">12</Data>) before inference is performed.</p>
  
  <p>Attribute <code>uri</code> is replaced with <code>iri</code>.
    This attribute is used to identify, by International Resource Identifier (IRI),
  the elements <code>Ind</code>, <code>Rel</code> and <code>Fun</code> as individuals,
  relations and functions, respectively. For example: 
    <box><pre><![CDATA[<Atom>
  <op>
    <Rel iri="http://dublincore.org/documents/dces/index.shtml.rdf#Creator"/>
  </op>
  <Ind iri="http://www.w3.org/Home/Lassila"/>
  <Data xsi:type="xs:string">Ora Lassila</Data>
</Atom>]]></pre></box>
expresses a fact equivalent to the RDF triple:      
    <box><pre><![CDATA[<rdf:RDF xmlns:s="http://dublincore.org/documents/dces/index.shtml.rdf">
  <rdf:Description about="http://www.w3.org/Home/Lassila">
    <s:Creator>Ora Lassila</s:Creator>
  </rdf:Description>
</rdf:RDF>]]></pre></box>
 </p> 
  <p>New role tag <code>act</code> is introduced for all content of the <code>RuleML</code> element, as shown here:
      
    <box><pre><![CDATA[<RuleML>
  <act>
    <Assert/>
  </act>
</RuleML>]]></pre></box></p>
  
</section>

<section>
	<header>Examples</header>
	<p>Numerous sample RuleML documents have been prepared and maintained; some exemplify features of RuleML and are useful didactically while others are mostly for testing puposes. Updated examples (e.g., <a href="exa/Datalog/own.ruleml">own.ruleml</a> and <a href="exa/Datalog/reify.ruleml">reify.ruleml</a>) accompany the 1.0 release and can be found with all the others in the <a href="exa/">Examples</a> directory.</p>

	<p>Examples from previous versions of RuleML are also maintained, e.g. <a href="http://www.ruleml.org/0.91/exa/">0.91 examples</a>).</p>
</section>

  <section label="Mapping">
    <header>Attribute Mapping</header>
    <p>There are three pairs of attributes in RuleML that have names which differ only by a 'map' prefix: <code>closure</code> and <code>mapClosure</code>, <code>direction</code> and <code>mapDirection</code>, and <code>material</code> and <code>mapMaterial</code>. The naming convention reflects attribute 'mapping' through XML trees, where</p>
    <p><pre><![CDATA[<TypeTag mapAttribute="..."><c1>. . .</c1>. . .<cN>. . .</cN></TypeTag>]]></pre></p>
    <p>basically acts like</p>
    <p><pre><![CDATA[<TypeTag><c1 attribute="...">. . .</c1>. . .<cN attribute="...">. . .</cN></TypeTag>]]></pre></p>
  </section>
  

<section>
<header>XSLT-Based Upgrader</header>
	<p>Continuing the practice begun in <a href="http://www.ruleml.org/0.86">0.86</a>, an XSLT stylesheet named
	<a href="xslt/upgrader/091-to-100.xslt">091-to-100.xslt</a> has been created to
	automatically update RuleML 0.91 documents to 1.0.  For instance,
	taking the <a href="xslt/upgrader/discount_091.ruleml">discount example from 0.91</a> as input, the stylesheet outputs
	the following: <a href="xslt/upgrader/discount_100.ruleml">discount_100.ruleml</a>. 
	(See a <a href="xslt/upgrader/discount-diff.htm">comparison of these two files</a> generated using
	<a href="http://www.componentsoftware.com/products/htmldiff/">HTML Diff</a>, noting that the differences are minor since
1.0 mostly builds on top of 0.91.)  Additional translation
	output samples are found in the <a href="xslt/upgrader/">Upgrader</a> directory. 
	  <!-- In the <a href="xslt/upgrader/comparison/">comparison</a> directory a comparison between manual and automatic updates of few files from the 0.91 exa directory can be found.-->
	</p>
	
	<p>Upgrader transformation can be accomplished using a web-based XSLT transformation tool provided by W3C. Instructions for this process can be found in <a href="#Appendix-4">Appendix 4.</a></p>
	<p>The stylesheet has also been tested
	  using <a href="http://www.oxygenxml.com">oXygen version 12.2</a>, 
	  whereby it was confirmed that all examples in the directory <a href="http://ruleml.org/1.0/exa/">http://ruleml.org/1.0/exa</a> are properly upgraded.
	  However, the upgraded instances documents will have the RuleML namespace as the default namespace, 
	  independent of the choice of prefix for the RuleML namespace in the original instance.
	  A similar <a href="xslt/upgrader/091-to-ruleml100.xslt">091-to-ruleml100.xslt</a> has been developed that uses the prefix "ruleml" for the RuleML namespace.
	  <!--and <a href="http://www.altova.com/products_ide.html">XML Spy</a>-->
	  </p>
	
	<p>An XSLT processor which may be used to perform these transformations on a whole directory at once is 
	<a href="http://www.saxonica.com/">Saxon</a>, using the following command:</p>
<p><code><![CDATA[   $ java net.sf.saxon.Transform -o 1.0/exa/ 0.91/exa/ 091-to-100.xslt]]></code></p>

<p>A use example of the Upgrader is described in the <a href="http://ruleml.org/usecases/wineonto/">WineOnto migration path documentation</a>.</p>
	
</section>

<section label="Normalization">
	<header>XSLT-Based Normalizer</header>

	<p>An XSLT stylesheet will be developed (<a href="http://www.ruleml.org/1.0/xslt/normalizer/100_normalizer.xslt">100_normalizer.xslt</a>) for normalizing the syntax used in a given RuleML 1.0 instance, reconstructing all skipped role tags to be in a fully-expanded, normal form.  An example is the <a href="xslt/normalizer/own_compact.ruleml">compact version of the 'own' example</a>.The goal of this normalizer is the following:</p>
<itemize>
<!--<item>Pre-validate to test that all element names, taken individually, belong to RuleML 1.0. This works for all given child permutations but does not check for syntax unlike the RuleML validation.</item>-->
<item>Reconstruct all skipped or optional role tags to be in a fully-expanded normal form also known as fully striped form.</item>
<item>Perform canonical child ordering of sub-elements.</item>
</itemize>
<p>We say that using this normalizer followed by XSD-based RuleML validation performs "normalidation" on RuleML instances. That is to say, not only are skipped or missing role tags inserted into the RuleML 1.0 instance in order to normalize it, but the general tree structure of the file is also validated syntactically to insure that type and role tags only appear in correct positions.</p>

The following is a list of the operations the XSLT Normalizer should perform whenever it is used on a RuleML 1.0 file. It includes adding missing role tags, rearranging elements into the canonical order and making attributes with default values explicit.

<itemize>
<item>Implies, Entails
	<itemize>
		<!-- <item>Makes sure, 'if'-'then' (or 'then'-'if') structure exists.</item>-->
	  <item>When 'if'-'then' role tags are both missing, wraps 'if' role tag on the first child, and 'then' tag on the second child.</item>
	  <item>If exactly one of 'if'-'then' role tags are missing, wraps the missing tag on the naked Node.</item>
	  <item>Switches 'then'-'if' children so that it is in 'if'-'then' format. </item>
	</itemize>
</item>

<item>
	Expr
	<itemize>
	  <item>If there is no 'op' tag, wrap 'Fun' tag with 'op' role tag if it does not already exist.</item>
	  <item>Adds 'arg' role tag (with an index attribute) to all the naked Nodes, including: 'Ind','Var','Fun','Plex','Reify','Data', or 'Skolem'.</item>
	  <item>Re-order the child elements as 'op', followed by positional arguemnts ('arg', then 'repo')
	  followed by slotted arguemnts ('slot', then 'resl').</item>
	</itemize>
</item>

<item>
Atom
	<itemize>
	  <item>If there is no 'op' tag, wrap 'Rel' tag with 'op' role tag if it does not already exist.</item> 
	  <item>Adds 'arg' role tag (with an index attribute) to all the naked Nodes, including: 'Ind','Var','Fun','Plex','Reify','Data', or 'Skolem'.</item>
	  <item>Re-order the child elements as 'op', followed by positional arguemnts ('arg', then 'repo')
	    followed by slotted arguemnts ('slot', then 'resl').</item>
	</itemize>
</item>

<item>
Uniterm
	<itemize>
	  <item>If there is no 'op' tag, wrap the first child that is not 'oid' or 'degree' with the 'op' tag.</item>
	  <item>Adds 'arg' role tag (with an index attribute) to all the remaining naked child Nodes, including: 'Const','Var','Reify','Uniterm','Skolem'.</item>
	  <item>Re-order the child elements as 'op', followed by positional arguemnts ('arg', then 'repo')
	    followed by slotted arguemnts ('slot', then 'resl').</item>
	</itemize>
</item>

<item>
Assert, Retract, Query, And, Or
	<itemize>
		<item>Wraps naked child Nodes with 'formula' role tag.</item>
	</itemize>
</item>
  <item>
    Forall, Exists
    <itemize>
      <item>Wraps naked 'Var' child Nodes with 'declare' role tag.</item>
      <item>Wraps any other naked child Nodes with 'formula' role tag.</item>
    </itemize>
  </item>

<item>
RuleML
	<itemize>
	  <item>Wraps naked child Nodes with 'act' role tag.</item>
	</itemize>
</item>

<item>
Neg
	<itemize>
	  <item>Wraps a naked child Node with 'strong' role tag.</item>
	</itemize>
</item>

<item>
Naf
	<itemize>
	  <item>Wraps a naked child Node with 'weak' role tag.</item>
	</itemize>
</item>

<item>
Equivalent
	<itemize>
	  <item>Wraps any naked child Node with 'torso' role tag.</item>
	</itemize>	
</item>

<item>
Equal
	<itemize>
	  <item>If there are two naked child Nodes, wraps first child with 'left' tag and second child with 'right' tag.  </item>
		<item>
		 Partial completion is also accepted. Example: if the first child has a 'left' role tag, and the second child has no 'left' or 'right' role tag, the XSLT will wrap the second child with the 'right' role tag.
		</item>
	</itemize>
</item>

</itemize>

<p>For example, <a href="http://www.ruleml.org/1.0/xslt/normalizer/own_compact.ruleml">the compact version of the 'own' example</a>:
  <box><pre><![CDATA[<RuleML>
  <Assert mapClosure="universal">
    <Implies>
      <And>
        <Atom>
          <Rel>buy</Rel>
          <Var>person</Var>
          <Var>merchant</Var>
          <Var>object</Var>
        </Atom>
        <Atom>
          <Var>person</Var>
          <Rel>keep</Rel>
          <Var>object</Var>
        </Atom>
      </And>
      <Atom>
        <Var>person</Var>
        <Rel>own</Rel>
        <Var>object</Var>
      </Atom>
    </Implies>
    ...
    <Atom>
      <Ind>Mary</Ind>
      <Rel>keep</Rel>
      <Ind>XMLBible</Ind>
    </Atom>
  </Assert>
</RuleML>
  ]]></pre></box>
is normalized to the <a href="xslt/normalizer/own_expanded.ruleml">expanded version</a>:

  <box><pre><![CDATA[<RuleML>
  <act index="1">
  <Assert mapClosure="universal">
      <formula>
        <Implies>
          <if>
            <And>
              <formula>
                <Atom>
                  <op><Rel>buy</Rel></op>
                  <arg index="1"><Var>person</Var></arg>
                  <arg index="2"><Var>merchant</Var>	</arg>
                  <arg index="3"><Var>object</Var></arg>
                </Atom>
              </formula>
              <formula>
                <Atom>
                  <op><Rel>keep</Rel></op>
                  <arg index="1"><Var>person</Var></arg>
                  <arg index="2"><Var>object</Var></arg>
                </Atom>
              </formula>
            </And>
          </if>
          <then>
            <Atom>
              <op><Rel>own</Rel></op>
              <arg index="1"><Var>person</Var></arg>
              <arg index="2"><Var>object</Var></arg>
            </Atom>
          </then>
        </Implies>
      </formula>
      ...
      <formula>
        <Atom>
          <op><Rel>keep</Rel></op>
          <arg index="1"><Ind>Mary</Ind></arg>
          <arg index="2"><Ind>XMLBible</Ind></arg>
        </Atom>
      </formula>
  </Assert>
  </act>
</RuleML>]]></pre></box>

(See a <a href="xslt/normalizer/own_compare.htm">comparison of these two files</a> generated using
<a href="http://www.componentsoftware.com/products/htmldiff/">HTML Diff</a>.)</p>

<p>Additional examples are located in the <a href="xslt/normalizer/">Normalizer</a> directory.</p>

<!--<p> THIS SWITCH IS NOT NEEDED IN THE PUSH-STYLE NORMALIZER @@@ The RuleML 1.00 normalizer contains a simple tag debugging tool that allows users to find tags that do not belong to RuleML. By setting variable DEBUG to true in the XSLT file, while transforming, the XSLT wraps the children of the incorrect tag with the PARENTERROR tag. This is significantly better than not having the transformation completed due to errors with no reason given.</p>-->

<p>XSLT processing can be accomplished using procedures identical to those of the XSLT Upgrader. Instructions for the W3C web-based process can be found in <a href="#Appendix-4">Appendix 4.</a></p>

</section>


<section>
	<header>Glossary</header>
	<p>The <a href="http://www.ruleml.org/1.0/glossary">glossary for RuleML 1.0</a> contains descriptions for every tag in RuleML 1.0.</p>
</section>

<section>
	<header>Modularization</header>
	<p>The XSD schemas use a tree-based modularization strategy. The most current model of the XSD modularization of RuleML is always documented at <a href="http://www.ruleml.org/modularization/#Model">http://www.ruleml.org/modularization/#Model</a>.</p>
  <p>The Relax NG schemas use a different modularization approach based on lattices. The details are given in <a href="http://www.cs.unb.ca/~boley/papers/RuleMLinRelaxNG.pdf">Design and Implementation of Highly Modular Schemas for XML: Customization of RuleML in Relax NG</a> and the RuleML <a href="http://wiki.ruleml.org/index.php/Relax_NG">MYNG</a> wiki page. A <a href="http://ruleml.org/1.0/myng/">GUI</a> to the Modular sYNtax confiGurator (MYNG) is available.</p>
</section>

<section>
	<header>XSDs</header>
	<p>A new<!--stable--> <a href="xsd/">XML Schema specification of RuleML 1.0</a> has been created using an <a href="http://www.ruleml.org/modularization/#Approach">approach</a> that is consistent with that of all earlier XSDs, and back to that of the (version 0.85) <a href="http://www.ruleml.org/0.85/dtd">DTDs</a>.
	   The <a href="xsd/content_models_10.pdf">Content Models for RuleML</a> should be read in parallel to the XML schemas, because they give a high-level, complete documentation of the XSDs.
	   Likewise, the <a href="http://ruleml.org/1.0/glossary/">Glossary</a> can help to find quick descriptions of, and cross-reference between, the RuleML/XML 1.0 tags.
	 </p>
</section>

<section>
<header>Appendices</header>

<p>Appended below is a simple example rulebase (<a href="#Appendix-1">Appendix 1</a>), the XML Schema for the Datalog sublanguage of RuleML to which the rulebase conforms (<a href="#Appendix-2">Appendix 2</a>), instructions for how to validate instances against the XSD schema (<a href="#Appendix-3">Appendix 3</a>),
  instructions for how to transform with XSLT stylesheets (<a href="#Appendix-4">Appendix 4</a>),  and
  instructions for how to validate instances against the  Relax NG schema (<a href="#Appendix-5">Appendix 5</a>).
</p>
</section>

<section label="Appendix-1">
<header>Appendix 1: New Example rulebase in RuleML</header>
<p>Source: <a href="exa/Datalog/own.ruleml">own.ruleml</a></p>
<box bgcolor="#FFFFFF"><pre><![CDATA[

<?xml version="1.0" encoding="UTF-8"?>

<RuleML
xmlns="http://www.ruleml.org/1.0/xsd"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.ruleml.org/1.0/xsd http://www.ruleml.org/1.0/xsd/datalog.xsd"
>

  <Assert mapClosure="universal">

    <!-- start XML comment ...

    This example rulebase contains four rules.
    The first and second rules are implications; the third and fourth ones are facts.

    In English:

    The first rule implies that a person owns an object
    if that person buys the object from a merchant and the person keeps the object.

    As an OrdLab Tree:

    Implies~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              *                                                                            *                       
           if *                                                                       then * 
              *                                                                            *  
             And~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                                 Atom~~~~~~~~~~~~~~~~~~
                   |                                   |                                          *     |     |  
                   |                                   |                                      op  *     |     |  
                   |                                   |                                          *     |     |    
                 Atom~~~~~~~~~~~~~~~~~~~~~~~~~~~     Atom~~~~~~~~~~~~~~~~~~                      Rel   Var   Var
                          *     |      |       |              *     |     |                       .     .     .    
                      op  *     |      |       |          op  *     |     |                       .     .     .    
                          *     |      |       |              *     |     |                       .     .     .
                         Rel   Var    Var     Var            Rel   Var   Var                     own  person object
                          .     .      .       .              .     .     . 
                          .     .      .       .              .     .     .
                          .     .      .       .              .     .     .
                         buy  person merchant object        keep  person object

    ... end XML comment -->

    <Implies>
      <if>
        <!-- explicit 'And' -->
        <And>
          <Atom>
            <op><Rel>buy</Rel></op>
            <Var>person</Var>
            <Var>merchant</Var>
            <Var>object</Var>
          </Atom>
          <Atom>
            <op><Rel>keep</Rel></op>
            <Var>person</Var>
            <Var>object</Var>
          </Atom>
        </And>
      </if>
      <then>
        <Atom>
          <op><Rel>own</Rel></op>
          <Var>person</Var>
          <Var>object</Var>
        </Atom>
      </then>
    </Implies>

  <!-- The second rule implies that a person buys an object from a merchant
  if the merchant sells the object to the person. -->

    <Implies>
      <if>
        <Atom>
          <op><Rel>sell</Rel></op>
          <Var>merchant</Var>
          <Var>person</Var>
          <Var>object</Var>
        </Atom>
      </if>
      <then>
        <Atom>
          <op><Rel>buy</Rel></op>
          <Var>person</Var>
          <Var>merchant</Var>
          <Var>object</Var>
        </Atom>
      </then>
    </Implies>
 
  <!-- The third rule is a fact that asserts that
  John sells XMLBible to Mary. -->
 

    <Atom>
      <op><Rel>sell</Rel></op>
      <Ind>John</Ind>
      <Ind>Mary</Ind>
      <Ind>XMLBible</Ind>
    </Atom>

 
  <!-- The fourth rule is a fact that asserts that
  Mary keeps XMLBible.
 
  Observe that this fact is binary - i.e., there are two arguments
  for the relation. RDF viewed as a logical knowledge representation
  is, likewise, binary, although its arguments have type restrictions,
  e.g., the first must be a resource (basically, a URI). -->
 
    <Atom>
      <op><Rel>keep</Rel></op>
      <Ind>Mary</Ind>
      <Ind>XMLBible</Ind>
    </Atom>
  </Assert>
 
</RuleML>]]></pre></box>
</section>

<section label="Appendix-2">
<header>Appendix 2: XSD for the Datalog sublanguage of RuleML</header>
<p>Source: <a href="xsd/datalog.xsd">datalog.xsd</a></p>

<box bgcolor="#FFFFFF"><pre><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>

<xs:schema 
xmlns="http://www.ruleml.org/1.0/xsd" 
xmlns:xs="http://www.w3.org/2001/XMLSchema" 
targetNamespace="http://www.ruleml.org/1.0/xsd"
>

	<xs:annotation>
		<xs:documentation xml:lang="en">
			XML Schema for the RuleML sublanguage "datalog".
			File: datalog.xsd
			Version: 1.0
			Last Modification: 2010-07-16
		</xs:documentation>
	</xs:annotation>

	<!--
		Note that datalog is entirely composed of modules and that all other
		schema drivers rely on it, making it the root of the sublanguage family tree.                 
	-->

	<!--
		Datalog includes the following modules:
		* performative
		* desc
		* quantifier
		* connective
		* atom
		* slot
		* term
		* uri

		For details on each module, including what element and/or attribute declarations                  
		they contain, please refer to them individually.
	-->

	<xs:include schemaLocation="modules/performative_module.xsd"/>
	<xs:include schemaLocation="modules/desc_module.xsd"/>
	<xs:include schemaLocation="modules/quantifier_module.xsd"/>
	<xs:include schemaLocation="modules/connective_module.xsd"/>
	<xs:include schemaLocation="modules/atom_module.xsd"/>
	<xs:include schemaLocation="modules/slot_module.xsd"/>
	<xs:include schemaLocation="modules/term_module.xsd"/>
	<xs:include schemaLocation="modules/uri_module.xsd"/>

</xs:schema>]]></pre></box>
</section>

<section label="Appendix-3">
<header>Appendix 3:  Instructions on validating the example online with XSD</header>
<enumerate>
  <li> Direct your browser to <a href="http://www.w3.org/2001/03/webdata/xsv">http://www.w3.org/2001/03/webdata/xsv</a></li>

  <li>Enter the following URL of our example RuleML file (or any other) into the textfield
    preceded by "Address(es)": http://www.ruleml.org/1.0/exa/Datalog/own.ruleml</li>

  <li>If desired, check the "Show Warnings" box.</li>

  <li>Click the "Get Results" button.</li>
</enumerate>

Note: The validation may take a while, and may require a full
refresh when re-validating to avoid caching.

Also note: Depending on your browser, you may want to select a different
output using the radio buttons just above the "Get Results" button.

<p> 
  You should get the following output (using the default output):</p>

		<h4>Schema validating with XSV 3.1-1 of 2007/12/11 16:20:05</h4>
		<ul>
			<li><b>Target</b>: <code>http://www.ruleml.org/1.0/exa/Datalog/own.ruleml</code><br/>   (Real name: http://www.ruleml.org/1.0/exa/Datalog/own.ruleml<br/>    Length: 4263 bytes
 <br/>    Last Modified: Sun, 18 Jul 2010 05:05:40 GMT<br/>    Server: Apache/2.0.55 (Red Hat)) </li>
			<li><b>docElt</b>: <code>{http://www.ruleml.org/1.0/xsd}RuleML</code></li>
			<li>Validation was strict, starting with type <code>{http://www.ruleml.org/1.0/xsd}:RuleML.type</code></li>
			<li><b>schemaLocs</b>: http://www.ruleml.org/1.0/xsd -&gt; http://www.ruleml.org/1.0/xsd/datalog.xsd</li>
			<li>The schema(s) used for schema-validation had no errors</li>
			<li>No schema-validity problems were found in the target </li>
		</ul>
		<hr/>
		<h3>Schema resources involved</h3>
		<p style="margin-bottom: 0px">Attempt to load a schema document from

<code>http://www.ruleml.org/1.0/xsd/datalog.xsd</code>
 (source: <code>schemaLoc</code>) for
   <code>http://www.ruleml.org/1.0/xsd</code>,
    succeeded</p>
		<p style="margin-bottom: 0px">Attempt to load a schema document from
<code>http://www.ruleml.org/1.0/xsd/modules/performative_module.xsd</code>
 (source: <code>include</code>) for
   <code>http://www.ruleml.org/1.0/xsd</code>,
    succeeded</p>
		<p style="margin-bottom: 0px">Attempt to load a schema document from
<code>http://www.ruleml.org/1.0/xsd/modules/desc_module.xsd</code>
 (source: <code>include</code>) for
   <code>http://www.ruleml.org/1.0/xsd</code>,
    succeeded</p>
		<p style="margin-bottom: 0px">Attempt to load a schema document from
<code>http://www.ruleml.org/1.0/xsd/modules/quantifier_module.xsd</code>
 (source: <code>include</code>) for
   <code>http://www.ruleml.org/1.0/xsd</code>,
    succeeded</p>
		<p style="margin-bottom: 0px">Attempt to load a schema document from
<code>http://www.ruleml.org/1.0/xsd/modules/connective_module.xsd</code>
 (source: <code>include</code>) for
   <code>http://www.ruleml.org/1.0/xsd</code>,
    succeeded</p>
		<p style="margin-bottom: 0px">Attempt to load a schema document from
<code>http://www.ruleml.org/1.0/xsd/modules/atom_module.xsd</code>
 (source: <code>include</code>) for
   <code>http://www.ruleml.org/1.0/xsd</code>,
    succeeded</p>
		<p style="margin-bottom: 0px">Attempt to load a schema document from
<code>http://www.ruleml.org/1.0/xsd/modules/slot_module.xsd</code>
 (source: <code>include</code>) for
   <code>http://www.ruleml.org/1.0/xsd</code>,
    succeeded</p>
		<p style="margin-bottom: 0px">Attempt to load a schema document from
<code>http://www.ruleml.org/1.0/xsd/modules/term_module.xsd</code>
 (source: <code>include</code>) for
   <code>http://www.ruleml.org/1.0/xsd</code>,
    succeeded</p>
		<p style="margin-bottom: 0px">Attempt to load a schema document from
<code>http://www.ruleml.org/1.0/xsd/modules/uri_module.xsd</code>
 (source: <code>include</code>) for
   <code>http://www.ruleml.org/1.0/xsd</code>,
    succeeded</p>      
		<hr/>
		

</section>

<section label="Appendix-4">
<header>Appendix 4:  Normalizing or Upgrading RuleML files with XSLT</header>
  <enumerate>
    <li>Go to the W3C XSLT Service at <a href ="http://www.w3.org/2005/08/online_xslt/">http://www.w3.org/2005/08/online_xslt/</a></li>

<li>For the xsl resource insert the URI for either the RuleML 1.0 Normalizer XSLT (<a href="http://ruleml.org/1.0/xslt/normalizer/100_normalizer.xslt">http://ruleml.org/1.0/xslt/normalizer/100_normalizer.xslt</a>)
or the RuleML 0.91-1.0 Upgrader XSLT (<a href = "http://ruleml.org/1.0/xslt/upgrader/091-to-100.xslt">http://ruleml.org/1.0/xslt/upgrader/091-to-100.xslt</a>).</li>

<li>For the xml resource use a file that is either considered compact RuleML (for the normalizer) or a RuleML file using an older version of RuleML (for the upgrader).
  Compact examples for the normalizer can be found <a href="http://ruleml.org/1.0/xslt/normalizer/">here</a> while old version examples for the upgrader can be found <a href="http://ruleml.org/1.0/xslt/upgrader/">here</a>.</li>

    <li>Once both URI's have been entered, click transform. To see the result, in some browsers you need to do "View | Page Source".</li>
  </enumerate>
</section>

<section label="Appendix-5">
  <header>Appendix 5:  Validating an Instance against a Relax NG schema</header>
  <a href="http://Validator.nu">Validator.nu</a> is an easy-to-use online tool for validating an XML instance against a Relax NG schema. A basic procedure for using this tool is as follows:
  <enumerate>
    <li>Open the <a href="http://Validator.nu">Validator.nu</a> webpage in your browser.</li>
    <li>Choose how you want to enter the instance:
      <itemize>
        <li>Address - type or past a URL into the adjacent text field;</li>
        <li>File Upload - use the browse dialog to locate the file on your local hard drive or network;</li>
        <li>Text Field - type or paste text directly into the text area.</li>
      </itemize>
    </li>
    <li>Skip the Encoding field</li>
    <li>Type or paste a URL to the schema you wish to validate against. Only schemas available from the internet can be used. For example, the URI <a href="http://ruleml.org/1.0/relaxng/schema_rnc.php">http://ruleml.org/1.0/relaxng/schema_rnc.php</a> may be used to validate all RuleML Version 1.0 instances.</li>
    <li>Skip the rest of the fields, and click Validate.</li>
    <li>The result will appear below, followed by a copy of the instance source.</li>
  </enumerate>
  An online demo of validation using the RuleML Relax NG schemas with Validator.nu, including more advanced options, is available at the <a href="http://wiki.ruleml.org/index.php/MYNG#Demo">Demos section of the MYNG</a> wiki page. Other tools that may be used for validation against Relax NG schemas are described in the <a href="http://wiki.ruleml.org/index.php/MYNG#Tools">Tools section of the MYNG</a> wiki page.
</section>

	<closing>
		<p>
		Site Contact:
		<a href="http://www.cs.unb.ca/~boley/">Harold Boley</a>.
		Page Version: 2011-09-21
		
		<br/>
		<br/>
		<br/>
		<a name="Practice-Preach"/>
		<small>"Practice what you preach": XML source of this homepage at <a href="index.xml">index.xml</a>;
	      <br/>
	      transformed to HTML via the adaptation of <a href="http://www.dfki.uni-kl.de/~sintek/">Michael Sintek</a>'s SliML <a href="http://www.w3.org/TR/xslt">XSLT</a> stylesheet at <a href="http://www.dfki.uni-kl.de/~boley/xslt/homepage.xsl">homepage.xsl</a> (View | Page Source)
	   </small>
		</p>
	</closing>

</homepage>

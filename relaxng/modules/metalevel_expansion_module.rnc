namespace dc = "http://purl.org/dc/elements/1.1/"
namespace dcterms = "http://purl.org/dc/terms/"
default namespace this = inherit

dc:title [ "RuleML Meta-Logic" ]
dc:version [ "1.02" ]
dc:creator [ "Tara Athan (taraathan AT gmail.com" ]
dc:subject [ "RuleML, Meta-logic, entails" ]
dc:description [ "The expansion module for the meta-logic components." ]
dc:language [ "en" ]
dcterms:rights [ "TBD" ] 
dc:relation [ "http://wiki.ruleml.org/index.php/Relax_NG" ]
start |= Entails.Node.def | head_Entails.edge.def | body_Entails.edge.def
Node.choice |= Entails.Node.def
edge.choice |= head_Entails.edge.def | body_Entails.edge.def
# Initialize patterns to allow the declaration of abstract elements while maintaining validity.
# This module declares or extends the following RuleML elements and attributes:
#            * <Entails>
#            * <if>
#            * <then>

## an extension point for specializations of the entailment tag name.  
Entails-node.choice |= Entails.Node.def
Entails.Node.def =
    
    ## Well-known in (meta-) logic (earlier called 'Turnstile', and 'Demo' in
    ##	Kowalski/Bowen's object/meta-level-amalgamated logic).
    ## See http://ruleml.org/1.02/glossary/#gloss-Entails 
    element Entails { Entails.type.def }
Entails.type.def = (Entails-datt.choice & reEntails.attlist), Entails.header, Entails.main
reEntails.attlist &= commonNode.attlist?

## Logical entailments accept the header pattern common to Nodes.
Entails.header &= Node.header?
# For the declaration of the Node header, see the modules meta_expansion_module).
# 
# Entails.main |= notAllowed is declared in the initialization module.
# This pattern must be over-ridden to allow the Entails element to be used.
# The pattern of the main content of an entailment is serialization dependent,
# but it will contain exactly one if and one then.
# For the declaration of the main content of entailments, see the serialization modules (orderstrict_module or orderlax_module)

## an extension point for stripe skipping as well as specializations of the if tag name in entailments.  
body_Entails.name.choice |= body_Entails.edge.def
body_Entails.edge.def =
    
    ## The if of an implication rule (<Implies>) containing the Premise(s), also known as the "antecedent" part of the rule. 
    ## Also used as the "antecedent" part of an entailment (<Entails>).
    ## See http://ruleml.org/1.02/glossary/#gloss-if
    ##  Within Entails...
    element if { body_Entails.type.def }
body_Entails.type.def = body_Entails.attlist? & body_Entails.content
body_Entails.attlist &= commonInit.attlist?

## The if of an entailment contains a single rulebase.
body_Entails.content |= Rulebase-node.choice
## The if of an entailment may contain a single formula that is allowed in a Rulebase.
body_Entails.content |= RulebaseFormula.choice

## an extension point for stripe skipping as well as specializations of the then tag name in entailments.  
head_Entails.name.choice |= head_Entails.edge.def
head_Entails.edge.def =
    
    ## The then of an implication rule (<Implies>) containing the conclusion, also known as the "consequent" or "then" part of the rule. 
    ## Also used as the "consequent" part of an entailment (<Entails>).
    ## See http://ruleml.org/1.02/glossary/#gloss-then
    ##  within Entails
    element then { head_Entails.type.def }
head_Entails.type.def = head_Entails.attlist? & head_Entails.content
head_Entails.attlist &= commonInit.attlist?

## The then of an entailment contains a single rulebase.
head_Entails.content |= Rulebase-node.choice
## The then of an entailment may contain a single formula that is allowed in a Rulebase.
head_Entails.content |= RulebaseFormula.choice

default namespace = "http://ruleml.org/spec"

start =
  InstanceOf
  | Implies
  | Assert
  | Naf
  | arg
  | Data
  | repo
  | Neg
  | Set
  | Expr
  | right
  | resl
  | op
  | Uniterm
  | declare
  | Fun
  | Plex
  | Forall
  | strong
  | Exists
  | then
  | Or
  | Entails
  | And
  | SubclassOf
  | torso
  | Query
  | Signature
  | Retract
  | Atom
  | oid
  | if
  | Const
  | Equal
  | Rulebase
  | left
  | slot
  | SlotProd
  | Reify
  | Equivalent
  | Ind
  | Rel
  | degree
  | Skolem
  | weak
  | Get
  | RuleML
  | Var
  | act
InstanceOf =
  element InstanceOf {
    (Var | Skolem | Reify | Const | Uniterm | Get | Set),
    (Var | Skolem | Reify | Const | Uniterm | Get | Set)
  }
Implies =
  element Implies {
    attribute material { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute direction {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    ((then, if)
     | (if, then)
     | ((And
         | Or
         | Naf
         | Uniterm
         | Neg
         | Equal
         | Atom_2
         | InstanceOf
         | SubclassOf
         | Signature),
        (Uniterm
         | Neg
         | Equal
         | Atom_2
         | InstanceOf
         | SubclassOf
         | Signature)))
  }
Assert =
  element Assert {
    attribute mapMaterial { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute mapClosure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    attribute mapDirection {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    oid?,
    (formula
     | Rulebase
     | Implies
     | Equivalent
     | Entails
     | Forall
     | Uniterm
     | Neg
     | Equal
     | Atom_2
     | InstanceOf
     | SubclassOf
     | Signature)*
  }
Naf = element Naf { oid?, (weak | Uniterm) }
arg =
  element arg {
    attribute index { xsd:positiveInteger },
    (Var | Skolem | Reify | Const | Uniterm | Get | Set)
  }
Data =
  element Data {
    text
    & (attribute * { text }
       | _1)*
  }
repo = element repo { Var | Plex_2 }
Neg = element Neg { oid?, (strong | Uniterm | And | Equal) }
Set =
  element Set { (Var | Skolem | Reify | Const | Uniterm | Get | Set)* }
Expr =
  element Expr {
    attribute per {
      xsd:NMTOKEN "open" | xsd:NMTOKEN "value" | xsd:NMTOKEN "copy"
    }?,
    attribute type { xsd:string }?,
    oid?,
    (op_2 | Fun),
    slot*,
    ((((arg | Var | Skolem | Reify | Const | Uniterm | Get | Set)+,
       repo?)
      | repo),
     slot*)?,
    resl?
  }
right =
  element right { Var | Skolem | Reify | Const | Uniterm | Get | Set }
resl = element resl { Var | Plex_3 }
op = element op { Rel }
Uniterm =
  element Uniterm {
    oid?,
    (op_3 | Const | Skolem | Var | Reify | Uniterm),
    slot*,
    resl?,
    ((((arg | Var | Skolem | Reify | Const | Uniterm | Get | Set)+,
       repo?)
      | repo),
     slot*,
     resl?)?
  }
declare = element declare { Var }
Fun =
  element Fun {
    text
    & (attribute val { xsd:NMTOKEN "1" | xsd:NMTOKEN "0.." }?,
       attribute per {
         xsd:NMTOKEN "open" | xsd:NMTOKEN "value" | xsd:NMTOKEN "copy"
       }?,
       attribute iri { xsd:anyURI }?)
  }
Plex =
  element Plex {
    oid?,
    slot*,
    (((arg | Var | Skolem | Reify | Const | Uniterm | Get | Set)+,
      repo?,
      slot*,
      resl?)?
     | (repo, slot*, resl?)
     | resl)
  }
Forall =
  element Forall {
    oid?,
    (declare | Var)+,
    (formula_2
     | Implies
     | Equivalent
     | Forall
     | Uniterm
     | Equal
     | Atom_2
     | InstanceOf
     | SubclassOf
     | Signature)
  }
strong = element strong { Uniterm | And | Equal }
Exists =
  element Exists {
    oid?,
    (declare | Var)+,
    (formula_3
     | And
     | Or
     | Exists
     | Uniterm
     | Equal
     | Atom_2
     | InstanceOf
     | SubclassOf
     | Signature)
  }
then =
  element then {
    Uniterm | Neg | Equal | Atom_2 | InstanceOf | SubclassOf | Signature
  }
Or =
  element Or {
    oid?,
    (formula_4
     | And
     | Or
     | Naf
     | Uniterm
     | Neg
     | Equal
     | Atom_2
     | InstanceOf
     | SubclassOf
     | Signature)*
  }
Entails =
  element Entails { oid?, (if_2 | Rulebase), (then_2 | Rulebase) }
And =
  element And {
    oid?,
    (formula_4
     | And
     | Or
     | Naf
     | Uniterm
     | Neg
     | Equal
     | Atom_2
     | InstanceOf
     | SubclassOf
     | Signature)*
  }
SubclassOf =
  element SubclassOf {
    (Var | Skolem | Reify | Const | Uniterm | Get | Set),
    (Var | Skolem | Reify | Const | Uniterm | Get | Set)
  }
torso =
  element torso {
    Uniterm | Equal | Atom_2 | InstanceOf | SubclassOf | Signature
  }
Query =
  element Query {
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    (formula_5
     | Rulebase
     | And_2
     | Or_2
     | Entails
     | Exists
     | Naf
     | Uniterm
     | Neg
     | Equal
     | Atom_2
     | InstanceOf
     | SubclassOf
     | Signature)*
  }
Signature =
  element Signature {
    oid, (op_3 | Const | Skolem | Var | Reify | Uniterm)?, slot_2*
  }
Retract =
  element Retract {
    attribute mapMaterial { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute mapClosure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    attribute mapDirection {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    oid?,
    (formula
     | Rulebase
     | Implies
     | Equivalent
     | Entails
     | Forall
     | Uniterm
     | Neg
     | Equal
     | Atom_2
     | InstanceOf
     | SubclassOf
     | Signature)*
  }
Atom =
  element Atom {
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    degree?,
    (op | Rel),
    slot*,
    ((((arg | Var | Skolem | Reify | Const | Uniterm | Get | Set)+,
       repo?)
      | repo),
     slot*)?,
    resl?
  }
oid = element oid { Var | Skolem | Reify | Const | Uniterm }
if =
  element if {
    And
    | Or
    | Naf
    | Uniterm
    | Neg
    | Equal
    | Atom_2
    | InstanceOf
    | SubclassOf
    | Signature
  }
Const =
  element Const {
    text
    & (attribute iri { xsd:anyURI }?,
       attribute type { xsd:string }?)
  }
Equal =
  element Equal {
    attribute oriented { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    oid?,
    degree?,
    ((left, right)
     | ((Var | Skolem | Reify | Const | Uniterm | Get | Set),
        (Var | Skolem | Reify | Const | Uniterm | Get | Set)))
  }
Rulebase =
  element Rulebase {
    attribute mapMaterial { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute mapDirection {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    attribute mapClosure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    (formula_6
     | Implies
     | Equivalent
     | Forall
     | Uniterm
     | Neg
     | Equal
     | Atom_2
     | InstanceOf
     | SubclassOf
     | Signature)*
  }
left =
  element left { Var | Skolem | Reify | Const | Uniterm | Get | Set }
slot =
  element slot {
    attribute weight {
      xsd:decimal { minInclusive = "0" maxInclusive = "1" }
    }?,
    attribute card { xsd:nonNegativeInteger }?,
    (Const | Uniterm | Get),
    (Var | Skolem | Reify | Const | Uniterm | Get | Set)
  }
SlotProd =
  element SlotProd {
    (Var | Skolem | Reify | Const | Uniterm | Get | Set)+
  }
Reify =
  element Reify {
    (InstanceOf
     | Implies
     | Assert
     | Naf
     | arg
     | Data
     | repo
     | Neg
     | Set
     | Expr
     | right
     | resl
     | op
     | Uniterm
     | declare
     | Fun
     | Plex
     | Forall
     | strong
     | Exists
     | then
     | Or
     | Entails
     | And
     | SubclassOf
     | torso
     | Query
     | Signature
     | Retract
     | Atom
     | oid
     | if
     | Const
     | Equal
     | Rulebase
     | left
     | slot
     | SlotProd
     | Reify
     | Equivalent
     | Ind
     | Rel
     | degree
     | Skolem
     | weak
     | Get
     | RuleML
     | Var
     | act)?
  }
Equivalent =
  element Equivalent {
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    ((torso, torso)
     | ((Uniterm
         | Equal
         | Atom_2
         | InstanceOf
         | SubclassOf
         | Signature),
        (Uniterm
         | Equal
         | Atom_2
         | InstanceOf
         | SubclassOf
         | Signature)))
  }
Ind =
  element Ind {
    text
    & (attribute iri { xsd:anyURI }?,
       attribute type { xsd:string }?)
  }
Rel =
  element Rel {
    text
    & attribute iri { xsd:anyURI }?
  }
degree = element degree { Data }
Skolem =
  element Skolem {
    text
    & attribute type { xsd:string }?
  }
weak = element weak { Uniterm }
Get = element Get { oid, SlotProd }
RuleML = element RuleML { oid?, (act | Assert | Retract | Query)* }
Var =
  element Var {
    text
    & attribute type { xsd:string }?
  }
act =
  element act {
    attribute index { xsd:positiveInteger },
    (Assert | Retract | Query)
  }
Atom_2 =
  element Atom {
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid,
    (op_3 | Const | Skolem | Var | Reify | Uniterm)?,
    slot_2*
  }
formula =
  element formula {
    Rulebase
    | Implies
    | Equivalent
    | Entails
    | Forall
    | Uniterm
    | Neg
    | Equal
    | Atom_2
    | InstanceOf
    | SubclassOf
    | Signature
  }
_1 =
  element * {
    text
    & (attribute * { text }
       | _1)*
  }
Plex_2 =
  element Plex {
    (arg | Var | Skolem | Reify | Const | Uniterm | Get | Set)*, repo?
  }
op_2 = element op { Fun }
Plex_3 = element Plex { slot*, resl? }
op_3 = element op { Const | Skolem | Var | Reify | Uniterm }
formula_2 =
  element formula {
    Implies
    | Equivalent
    | Forall
    | Uniterm
    | Equal
    | Atom_2
    | InstanceOf
    | SubclassOf
    | Signature
  }
formula_3 =
  element formula {
    And
    | Or
    | Exists
    | Uniterm
    | Equal
    | Atom_2
    | InstanceOf
    | SubclassOf
    | Signature
  }
formula_4 =
  element formula {
    And
    | Or
    | Naf
    | Uniterm
    | Neg
    | Equal
    | Atom_2
    | InstanceOf
    | SubclassOf
    | Signature
  }
if_2 = element if { Rulebase }
then_2 = element then { Rulebase }
formula_5 =
  element formula {
    Rulebase
    | And_2
    | Or_2
    | Entails
    | Exists
    | Naf
    | Uniterm
    | Neg
    | Equal
    | Atom_2
    | InstanceOf
    | SubclassOf
    | Signature
  }
And_2 =
  element And {
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    (formula_4
     | And
     | Or
     | Naf
     | Uniterm
     | Neg
     | Equal
     | Atom_2
     | InstanceOf
     | SubclassOf
     | Signature)*
  }
Or_2 =
  element Or {
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    (formula_4
     | And
     | Or
     | Naf
     | Uniterm
     | Neg
     | Equal
     | Atom_2
     | InstanceOf
     | SubclassOf
     | Signature)*
  }
slot_2 =
  element slot {
    attribute weight {
      xsd:decimal { minInclusive = "0" maxInclusive = "1" }
    }?,
    attribute maxCard { xsd:nonNegativeInteger }?,
    attribute minCard { xsd:nonNegativeInteger }?,
    attribute card { xsd:nonNegativeInteger }?,
    (Const | Uniterm | Get),
    (Var | Skolem | Reify | Const | Uniterm | Get | Set)?
  }
formula_6 =
  element formula {
    Implies
    | Equivalent
    | Forall
    | Uniterm
    | Neg
    | Equal
    | Atom_2
    | InstanceOf
    | SubclassOf
    | Signature
  }
